# -*- coding: utf-8 -*-
"""Copia de Actalizacion XNYUSDT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H9rGHnSeKf9kXj0_rG9-UnXAr76VrV_R
"""

import requests
import pandas as pd
import time
import ta
import pytz
import os
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# --- CONFIGURACIÃ“N INICIAL ---
BASE_URL = 'https://api.kucoin.com'
SYMBOL = 'XNY-USDT'
TIME_FRAMES = ['1min', '5min', '15min', '1hour', '4hour', '1day']

def get_kucoin_klines(symbol, timeframe):
    endpoint = f'{BASE_URL}/api/v1/market/candles'
    params = {'symbol': symbol, 'type': timeframe}
    try:
        response = requests.get(endpoint, params=params)
        data = response.json()
        if data['code'] == '200000' and data['data']:
            df = pd.DataFrame(data['data'], columns=['timestamp', 'open', 'close', 'high', 'low', 'volume', 'turnover'])
            df['timestamp'] = pd.to_datetime(df['timestamp'].astype(int), unit='s')
            for col in ['open', 'close', 'high', 'low', 'volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            df = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']].set_index('timestamp')
            return df
        return None
    except Exception as e:
        print(f"Error capturando datos: {e}")
        return None

def add_technical_indicators(df):
    df_sorted = df.sort_index(ascending=True).copy()
    df_sorted['EMA_55'] = ta.trend.ema_indicator(df_sorted['close'], window=55)
    df_sorted['EMA_10'] = ta.trend.ema_indicator(df_sorted['close'], window=10)
    df_sorted['RSI'] = ta.momentum.rsi(df_sorted['close'], window=14)
    df_sorted['ADX'] = ta.trend.adx(df_sorted['high'], df_sorted['low'], df_sorted['close'], window=14)
    # Bandas de Bollinger
    df_sorted['BBL_UPPER'] = ta.volatility.bollinger_hband(df_sorted['close'], window=20, window_dev=2)
    df_sorted['BBL_LOWER'] = ta.volatility.bollinger_lband(df_sorted['close'], window=20, window_dev=2)
    return df_sorted.sort_index(ascending=False)

def send_telegram_alert(message):
    # En Colab, puedes definir estas variables temporalmente para probar:
    # os.environ['TELEGRAM_BOT_TOKEN'] = 'TU_TOKEN'
    # os.environ['TELEGRAM_CHAT_ID'] = 'TU_ID'

    token = os.environ.get('TELEGRAM_BOT_TOKEN')
    chat_id = os.environ.get('TELEGRAM_CHAT_ID')

    if not token or not chat_id:
        print("âš ï¸ Alerta no enviada: Faltan variables de entorno TELEGRAM_BOT_TOKEN o TELEGRAM_CHAT_ID")
        return

    url = f"https://api.telegram.org/bot{token}/sendMessage?chat_id={chat_id}&parse_mode=Markdown&text={message}"
    try:
        requests.get(url)
        print("âœ… Mensaje de Telegram enviado.")
    except Exception as e:
        print(f"âŒ Error enviando a Telegram: {e}")

def run_prediction_cycle():
    trained_models = {}
    accuracy_scores = {}

    print(f"--- Iniciando Ciclo de PredicciÃ³n para {SYMBOL} ---")

    # 1. Entrenamiento de modelos para cada temporalidad
    for timeframe in TIME_FRAMES:
        df = get_kucoin_klines(SYMBOL, timeframe)
        if df is not None:
            df = add_technical_indicators(df)
            df['target'] = (df['close'].shift(1) > df['close']).astype(int)
            df.dropna(inplace=True)

            # Definir caracterÃ­sticas (X) y objetivo (y)
            X = df.drop(columns=['open', 'high', 'low', 'close', 'volume', 'target'])
            y = df['target']

            if len(df) > 20: # Asegurar datos suficientes
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)
                model = LogisticRegression(solver='liblinear', random_state=42)
                model.fit(X_train, y_train)

                trained_models[timeframe] = model
                accuracy_scores[timeframe] = accuracy_score(y_test, model.predict(X_test))
                print(f"Modelo {timeframe} entrenado. PrecisiÃ³n: {accuracy_scores[timeframe]:.2%}")

    # 2. VerificaciÃ³n especÃ­fica para la alerta de 15 minutos
    tf_alert = '15min'
    if tf_alert in trained_models:
        df_now = get_kucoin_klines(SYMBOL, tf_alert)
        if df_now is not None:
            df_now = add_technical_indicators(df_now).dropna()
            # Tomar la Ãºltima fila para predecir
            X_latest = df_now.drop(columns=['open', 'high', 'low', 'close', 'volume']).head(1)

            proba_up = trained_models[tf_alert].predict_proba(X_latest)[0][1]
            proba_down = 1 - proba_up
            highest_proba = max(proba_up, proba_down)
            direction = "Subir ğŸ“ˆ" if proba_up >= proba_down else "Bajar ğŸ“‰"

            print(f"Probabilidad detectada (15min): {highest_proba:.2%}")

            # CondiciÃ³n de activaciÃ³n: > 70%
            if highest_proba > 0.70:
                precio = df_now['close'].iloc[0]
                bogota_now = df_now.index[0].tz_localize('UTC').astimezone(pytz.timezone('America/Bogota'))

                msg = (f"ğŸš¨ *ALERTA DE PROBABILIDAD ALTA ({tf_alert})*\n\n"
                       f"ğŸ’° *Precio:* {precio:.8f}\n"
                       f"ğŸ”® *PredicciÃ³n:* El precio tiende a *{direction}*\n"
                       f"ğŸ¯ *Probabilidad:* {highest_proba:.2%}\n"
                       f"ğŸ“Š *Confianza del Modelo:* {accuracy_scores[tf_alert]:.2%}\n"
                       f"â° *Hora BogotÃ¡:* {bogota_now.strftime('%H:%M:%S')}")
                send_telegram_alert(msg)
            else:
                print("La probabilidad no supera el 70%. No se envÃ­a alerta.")

# Ejecutar el proceso
if __name__ == "__main__":
    run_prediction_cycle()
